<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - FBX loader</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <!-- <link type="text/css" rel="stylesheet" href="/fbx/main.css"> -->
</head>

<body>
  <div id="info">
    <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - FBXLoader<br />
    Character and animation from <a href="https://www.mixamo.com/" target="_blank" rel="noopener">Mixamo</a>
  </div>

  <!-- Import maps polyfill -->
  <!-- Remove this when import maps will be widely supported -->
  <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.143.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">

    import * as THREE from 'three';

    import Stats from 'https://cdn.jsdelivr.net/npm/three@0.143.0/examples/jsm/libs/stats.module.js';

    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.143.0/examples/jsm/controls/OrbitControls.js';
    import { FBXLoader } from 'https://cdn.jsdelivr.net/npm/three@0.143.0/examples/jsm/loaders/FBXLoader.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.143.0/examples/jsm/loaders/GLTFLoader.js';

    // console.log(Object.keys(THREE))

    let camera, scene, renderer, stats;

    // clock 和動畫有關
    const clock = new THREE.Clock();

    // mixer 和動畫有關
    let mixer;

    // 1. 先 init
    init();

    // 2. 再搞動畫
    animate();

    // init 做的事
    function init() {

      // 填加一個 container div 在 body 裡
      const container = document.createElement('div');
      document.body.appendChild(container);

      // 創建鏡頭和調鏡頭位置
      // 60, 景深
      // 2000 能見度
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.set(0, 200, 300);

      // 建立三維場景
      // 背景
      // 要不要霧
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xa0a0a0);
      // scene.fog = new THREE.Fog(0xa0a0a0, 200, 1000);

      // 增加光源
      // 半球燈
      // up color: 0xffffff
      // down color: 0x444444
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
      hemiLight.position.set(0, 200, 0);
      scene.add(hemiLight);

      // 增加直射燈
      // 這個和陰影有關係
      const dirLight = new THREE.DirectionalLight(0xffffff);
      dirLight.position.set(0, 200, 100);
      dirLight.castShadow = true;
      dirLight.shadow.camera.top = 180;
      dirLight.shadow.camera.bottom = - 100;
      dirLight.shadow.camera.left = - 120;
      dirLight.shadow.camera.right = 120;
      scene.add(dirLight);

      // 陰影 camera 位置的線
      // scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );

      // 增加地下
      // ground
      // 白色的地板
      // const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false }));
      // mesh.rotation.x = - Math.PI / 2;
      // mesh.receiveShadow = true;
      // scene.add(mesh);
      // // 網格狀地板
      // const grid = new THREE.GridHelper(2000, 20, 0x000000, 0x000000);
      // grid.material.opacity = 0.2;
      // grid.material.transparent = true;
      // scene.add(grid);

      // 載入三維模型
      const loader = new GLTFLoader();
      loader.load('models/Voxel_RabbitB.glb', function (gltf) {
        gltf.scene.scale.set(200,200,200);

        mixer = new THREE.AnimationMixer(gltf.scene);

        console.log(gltf.animations)

        const action = mixer.clipAction(gltf.animations[0]);
        action.play();

        // 陰影部分
        // 讓三維模型產生陰影在地板上
        // object.traverse(function (child) {

        //   if (child.isMesh) {

        //     child.castShadow = true;
        //     child.receiveShadow = true;

        //   }

        // });

        gltf.scene.position.set(0, 100, 0);

        // const gltfCamera = gltf.cameras[0];
        // camera = new THREE.PerspectiveCamera(
        //   gltfCamera.fov,
        //   window.innerWidth / window.innerHeight,
        //   // カメラのnearとfarはFBXに変換したときにセンチメートル単位になり、
        //   // FBX2glTFではメートルに変換してくれないので、ここでメートル単位に変換する
        //   gltfCamera.near * 0.01,
        //   gltfCamera.far * 0.01
        // );
        // // カメラアニメーションに存在する謎回転に対処するために、
        // // 相殺する回転をかけてglTFカメラの子要素に追加する
        // camera.rotation.set(0, -0.5 * Math.PI, 0);
        // gltfCamera.add(camera);

        scene.add(gltf.scene);

      });

      // const geometry = new THREE.BoxGeometry(50, 50, 50);
      // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      // const cube = new THREE.Mesh(geometry, material);
      // cube.position.set(0, 50, 0);
      // cube.castShadow = true;
      // cube.receiveShadow = true;
      // scene.add(cube);

      // 創建 renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      // 把 renderer 加到 container
      container.appendChild(renderer.domElement);

      // 需要一點控制嗎?
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 100, 0);
      controls.update();

      // 當視窗大小改變時
      window.addEventListener('resize', onWindowResize);

      // fps 數據加到 container
      // stats
      stats = new Stats();
      container.appendChild(stats.dom);

    }

    // 改變視窗大小需要重新調整 camera 和 renderer
    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

    }

    // 不斷 render 三維場景
    function animate() {

      requestAnimationFrame(animate);

      let delta = clock.getDelta();

      delta *= 0.5;

      if (mixer) mixer.update(delta);

      renderer.render(scene, camera);

      stats.update();

    }

  </script>

</body>

</html>